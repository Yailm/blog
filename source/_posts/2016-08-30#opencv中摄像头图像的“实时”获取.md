title: opencv中摄像头图像的“实时”获取
date: 2016-08-30 23:39:41
tags:
  opencv
---
这段时间要做项目学习了下opencv，准备通过摄像头来捕捉人体。心里有个疑问，对于从摄像头获取的图像，如果对图像的分析处理时间很长，那么下一次再从摄像头获取的图像是什么时候的呢？有两个选项，一个是紧临上一次的图像，或者是处理结束后即时获取的图像。正好准备解决这个问题，写了代码来验证一下

    import cv2
    import time

    cap = cv2.VideoCapture(0)
    for i in range(15):
        ret, image = cap.read()
        cv2.imwrite('/tmp/image%02d.jpg' % i, image)
        print("get", i+1)
        time.sleep(3)   # 代替耗时的操作
    cap.release()

那，这个程序怎么验证呢？用手机开个秒表，计时并放在摄像头前面，之后所有的图片得到这样的结果

01.78s（手机移动到摄像头花了点时间）
01.81s
01.85s
01.87s
01.92s
04.83s
07.84s
....大概后面都能以约3秒的间隔
最后是31.95s，而我一结束就马上关闭了秒表，停留在48.35s

出现这样的结果，能马上想到获取的图像其实是有缓冲区的，大小为5张图片的样子，而其后能保持间隔，不正是生产者消费者的问题吗？

假设摄像头以每秒30帧获取图像的话，那么程序就是每3秒才取走一张图片，进而促使摄像头继续获取图像。不难解释后面31.95和45.35s
此时应该是31.95的图片在缓冲区的底端，类似这样

44.10
41.05
38.01
34.98
31.95

当31.95被取出的时候，(44.10+3s)才进入缓冲区，这才是当时真正的时间

所以，当我们调用摄像头并对图像使用耗时的操作时，是没有做到实时的。可以事先计算图像操作的耗时（一般都会比读取的时间多），只要知道它大于读取耗费的时间，那么我们就能知道这样一个结论：`当我们获取的图像的时候，缓冲区都是满的`，而且是以前的图像，真正想要的在缓冲区外面，所以只要读取并舍弃这些图像

    for x in range(5): cap.read()

这样，摄像头就能称得上是实时的了
